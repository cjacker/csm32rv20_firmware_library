#include "headfile.h"



void Timer1_UpCounting_Mode_Init(void)//向上计数
{
    TIMER1->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                            //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER1->PSC = 31;//预分频
    TIMER1->ARR = 1000;//自动重装寄存器
	TIMER1->RCR = 0;//重复计数
	TIMER1->IER = 1;//使能中断：1-使能，0-关闭
                    //IER[7]-刹车中断
                    //IER[6]-触发中断
                    //IER[5]-COM中断
                    //IER[4]-捕获/比较4中断
                    //IER[3]-捕获/比较3中断
                    //IER[2]-捕获/比较2中断
                    //IER[1]-捕获/比较1中断
                    //IER[0]-更新中断

    TIMER1->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 0 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

	TIMER1->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件

}

void Timer1_6StepPWM_Mode_Init(void)//6stepPWM输出
{
	//GPIOA9~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN2, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN3, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN4, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN5, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN6, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN7, GPIO_MODE_AF);

	GPIO_AF_Init(GPIOA,  PIN2,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN3,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN4,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN5,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN6,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN7,  GPIO_AF2);

    TIMER1->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER1->PSC = 15;//预分频
    TIMER1->ARR = 100;//自动重装寄存器
	TIMER1->RCR = 0;//重复计数

	TIMER1->CCR1 = 50;//捕获/比较值1
	TIMER1->CCR2 = 50;//捕获/比较值2
	TIMER1->CCR3 = 50;//捕获/比较值3
	TIMER1->CCR4 = 50;//捕获/比较值4

	TIMER1->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER1->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

    TIMER1->CCER = 0<<15//CCER[15]-CC4NP-捕获/比较4互补输出极性：0-高电平有效，1-低电平有效
                |  1<<14//CCER[14]-CC4NE-捕获/比较4互补输出使能：0-关闭，1-开启
                |  0<<13//CCER[13]-CC4P -捕获/比较4输出极性：0-高电平有效，1-低电平有效
                |  1<<12//CCER[12]-CC4E -捕获/比较4输出使能：0-关闭，1-开启
                |  0<<11//CCER[11]-CC3NP-捕获/比较3互补输出极性：0-高电平有效，1-低电平有效
                |  1<<10//CCER[10]-CC3NE-捕获/比较3互补输出使能：0-关闭，1-开启
                |  0<<9 //CCER[9] -CC3P -捕获/比较3输出极性：0-高电平有效，1-低电平有效
                |  1<<8 //CCER[8] -CC3E -捕获/比较3输出使能：0-关闭，1-开启
                |  0<<7 //CCER[7] -CC2NP-捕获/比较2互补输出极性：0-高电平有效，1-低电平有效
                |  1<<6 //CCER[6] -CC2NE-捕获/比较2互补输出使能：0-关闭，1-开启
                |  0<<5 //CCER[5] -CC2P -捕获/比较2输出极性：0-高电平有效，1-低电平有效
                |  1<<4 //CCER[4] -CC2E -捕获/比较2输出使能：0-关闭，1-开启
                |  0<<3 //CCER[3] -CC1NP-捕获/比较1互补输出极性：0-高电平有效，1-低电平有效
                |  0<<2 //CCER[2] -CC1NE-捕获/比较1互补输出使能：0-关闭，1-开启
                |  0<<1 //CCER[1] -CC1P -捕获/比较1输出极性：0-高电平有效，1-低电平有效
                |  0<<0;//CCER[0] -CC1E -捕获/比较1输出使能：0-关闭，1-开启

	TIMER1->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 1<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 0<<0;//IER[0]-更新中断：1-使能，0-关闭

    TIMER1->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 3 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 6 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 1 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 1 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 3 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER1->BDTR = 1 <<15//BDTR[15]-MOE-主输出使能:0-关闭，1-使能
                |  0 <<14//BDTR[14]-AOE-自动输出使能:0-关闭，1-使能
                |  0 <<13//BDTR[13]-BKP-刹车输入极性:0-低电平有效，1-高电平有效
                |  0 <<12//BDTR[12]-BKE-刹车功能使能:0-关闭，1-使能
                |  0 <<11//BDTR[11]-OSSR-运行模式下“关闭状态”选择，定时器不工作时:0-禁止OC/OCN输出，1-一旦CCxE或CCxNE=1,OC/OCN输出空闲电平
                |  0 <<10//BDTR[10]-OSSI-空闲模式下“关闭状态”选择，定时器不工作时:0-禁止OC/OCN输出，1-一旦CCxE或CCxNE=1,OC/OCN输出空闲电平
                |  0 <<8 //BDTR[9:8]-LOCK-锁定设置：00-关闭，01-锁定级别1，10-锁定级别2，11-锁定级别3
                |  0 <<0;//BDTR[7:0]-LOCK-死区时间设置：

	TIMER1->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}


void Timer1_Break_IRQhandler(void)
{
    if(TIMER1->SR&0x80)
		TIMER1->SR &= ~0x80;
}
void Timer1_Update_IRQhandler(void)
{
	if(TIMER1->SR&0x1)
    {
        TIMER1->SR &= ~0x1;

        GPIO_Toggle(GPIOA,PIN12);
    }

}
void Timer1_Capture_Compare_IRQhandler(void)
{
	if(TIMER1->SR&0x20)
	{
		TIMER1->SR &= ~0x20;
	}
    if(TIMER1->SR&0x40)
    {
        TIMER1->SR &= ~0x40;
    }
}

uint8_t com_set1=0;
void Timer1_Trigger_Commutation_IRQhandler(void)
{
    if(TIMER1->SR&0x40)
		TIMER1->SR &= ~0x40;

    //GPIO_Write(GPIOA,PIN15,GPIO_SET);
	//GPIO_Write(GPIOA,PIN15,GPIO_RESET);

    //6step pwm
		switch(com_set1)
		{
			case 0:
			    //               C0        B-       A+
			    TIMER1->CCER = (0x0<<12)|(0x4<<8)|(0x1<<4)|(0x0); //1+,4-,0close

                TIMER1->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER1->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   5<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 1:
			    //               C-        B0       A+
				TIMER1->CCER = (0x4<<12)|(0x0<<8)|(0x1<<4)|(0x0); //1+,4-,0close

                TIMER1->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER1->CCMR2 = 5<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上


				break;

			case 2:
                //               C-        B+       A0
			    TIMER1->CCER = (0x4<<12)|(0x1<<8)|(0x0<<4)|(0x0); //1+,4-,0close
                TIMER1->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER1->CCMR2 = 5<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 3:
				//               C0        B+       A-
			    TIMER1->CCER = (0x0<<12)|(0x1<<8)|(0x4<<4)|(0x0); //1+,4-,0close

                TIMER1->CCMR1 = 5<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER1->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 4:
				//               C+        B0       A-
			    TIMER1->CCER = (0x1<<12)|(0x0<<8)|(0x4<<4)|(0x0); //1+,4-,0close
                TIMER1->CCMR1 = 5<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER1->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 5:
				//               C+        B-       A0
			    TIMER1->CCER = (0x1<<12)|(0x4<<8)|(0x0<<4)|(0x0); //1+,4-,0close

                TIMER1->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER1->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   5<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			default:
				break;
		}
		com_set1++;
		if(com_set1==6)
			com_set1=0;

    //GPIO_Write(GPIOB,PIN11,GPIO_SET);
	//GPIO_Write(GPIOB,PIN11,GPIO_RESET);
}


void Timer2_UpCounting_Mode_Init(void)//向上计数
{
    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭
    TIMER2->PSC = 15;//预分频：时钟频率=fCK_PSC/PSC[15:0]+1)
    TIMER2->ARR = 1000;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数
	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 0 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4///CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;///CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件

}

void Timer2_DownCounting_Mode_Init(void)//向下计数
{
    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭
    TIMER2->PSC = 15;//预分频：时钟频率=fCK_PSC/PSC[15:0]+1)
    TIMER2->ARR = 2000;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数
	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 0 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 1 <<4///CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;///CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件

}

void Timer2_ExternalClock_Mode_Init(void)//外部时钟
{
    //GPIOA9~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN8, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN8,  GPIO_AF2);
	GPIO_MODE_Init(GPIOA, PIN10, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN10,  GPIO_AF2);

    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER2->PSC = 0;//预分频
    TIMER2->ARR = 100;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数
	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

 	TIMER2->CCMR1 = 0<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   1<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER2->CCMR2 = 0<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   0<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上



    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 1 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 7 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER2->ICF = 0 <<12//ICF[15:12]-ICF4-输入捕获4滤波器：0000~111
                | 0 <<8 //ICF[11:8]-ICF3-输入捕获3滤波器：0000~111
                | 0 <<4 //ICF[7:4]-ICF2-输入捕获2滤波器：0000~111
                | 0 <<0;//ICF[3:0]-ICF1-输入捕获1滤波器：0000~111

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}


void Timer2_InputCapture_Mode_Init(void)//输入捕获
{
    //GPIOA8~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN8, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN8,  GPIO_AF2);

    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER2->PSC = 15999;//预分频
    TIMER2->ARR = 1000;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数
	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 1<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

 	TIMER2->CCMR1 = 0<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER2->CCMR2 = 0<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   0<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上




    TIMER2->CCER = 0<<15//CCER[15]-CC4NP-捕获/比较4互补输出极性：0-高电平有效，1-低电平有效
                |  0<<14//CCER[14]-CC4NE-捕获/比较4互补输出使能：0-关闭，1-开启
                |  0<<13//CCER[13]-CC4P -捕获/比较4输出极性：0-高电平有效，1-低电平有效
                |  0<<12//CCER[12]-CC4E -捕获/比较4输出使能：0-关闭，1-开启
                |  0<<11//CCER[11]-CC3NP-捕获/比较3互补输出极性：0-高电平有效，1-低电平有效
                |  0<<10//CCER[10]-CC3NE-捕获/比较3互补输出使能：0-关闭，1-开启
                |  0<<9 //CCER[9] -CC3P -捕获/比较3输出极性：0-高电平有效，1-低电平有效
                |  0<<8 //CCER[8] -CC3E -捕获/比较3输出使能：0-关闭，1-开启
                |  0<<7 //CCER[7] -CC2NP-捕获/比较2互补输出极性：0-高电平有效，1-低电平有效
                |  0<<6 //CCER[6] -CC2NE-捕获/比较2互补输出使能：0-关闭，1-开启
                |  0<<5 //CCER[5] -CC2P -捕获/比较2输出极性：0-高电平有效，1-低电平有效
                |  0<<4 //CCER[4] -CC2E -捕获/比较2输出使能：0-关闭，1-开启
                |  0<<3 //CCER[3] -CC1NP-捕获/比较1互补输出极性：0-高电平有效，1-低电平有效
                |  0<<2 //CCER[2] -CC1NE-捕获/比较1互补输出使能：0-关闭，1-开启
                |  0<<1 //CCER[1] -CC1P -捕获/比较1输入输出极性：0-高电平有效，1-低电平有效
                |  1<<0;//CCER[0] -CC1E -捕获/比较1输入输出使能：0-关闭，1-开启

    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 0 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER2->ICF = 0 <<12//ICF[15:12]-ICF4-输入捕获4滤波器：0000~111
                | 0 <<8 //ICF[11:8]-ICF3-输入捕获3滤波器：0000~111
                | 0 <<4 //ICF[7:4]-ICF2-输入捕获2滤波器：0000~111
                | 0 <<0;//ICF[3:0]-ICF1-输入捕获1滤波器：0000~111

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}


void Timer2_PWM_InputCapture_Mode_Init(void)//PWM输入捕获
{
    //GPIOA8~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN8, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN8,  GPIO_AF2);

    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭
    TIMER2->PSC = 15999;//预分频
    TIMER2->ARR = 1000;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数
	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 1<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 1<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

 	TIMER2->CCMR1 = 0<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   2<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER2->CCMR2 = 0<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   0<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

    TIMER2->CCER = 0<<15//CCER[15]-CC4NP-捕获/比较4互补输出极性：0-高电平有效，1-低电平有效
                |  0<<14//CCER[14]-CC4NE-捕获/比较4互补输出使能：0-关闭，1-开启
                |  0<<13//CCER[13]-CC4P -捕获/比较4输出极性：0-高电平有效，1-低电平有效
                |  0<<12//CCER[12]-CC4E -捕获/比较4输出使能：0-关闭，1-开启
                |  0<<11//CCER[11]-CC3NP-捕获/比较3互补输出极性：0-高电平有效，1-低电平有效
                |  0<<10//CCER[10]-CC3NE-捕获/比较3互补输出使能：0-关闭，1-开启
                |  0<<9 //CCER[9] -CC3P -捕获/比较3输出极性：0-高电平有效，1-低电平有效
                |  0<<8 //CCER[8] -CC3E -捕获/比较3输出使能：0-关闭，1-开启
                |  0<<7 //CCER[7] -CC2NP-捕获/比较2互补输出极性：0-高电平有效，1-低电平有效
                |  0<<6 //CCER[6] -CC2NE-捕获/比较2互补输出使能：0-关闭，1-开启
                |  1<<5 //CCER[5] -CC2P -捕获/比较2输出极性：0-高电平有效，1-低电平有效
                |  1<<4 //CCER[4] -CC2E -捕获/比较2输出使能：0-关闭，1-开启
                |  0<<3 //CCER[3] -CC1NP-捕获/比较1互补输出极性：0-高电平有效，1-低电平有效
                |  0<<2 //CCER[2] -CC1NE-捕获/比较1互补输出使能：0-关闭，1-开启
                |  0<<1 //CCER[1] -CC1P -捕获/比较1输出极性：0-高电平有效，1-低电平有效
                |  1<<0;//CCER[0] -CC1E -捕获/比较1输出使能：0-关闭，1-开启

    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 1 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 4 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER2->ICF = 0 <<12//ICF[15:12]-ICF4-输入捕获4滤波器：0000~111
                | 0 <<8 //ICF[11:8]-ICF3-输入捕获3滤波器：0000~111
                | 0 <<4 //ICF[7:4]-ICF2-输入捕获2滤波器：0000~111
                | 0 <<0;//ICF[3:0]-ICF1-输入捕获1滤波器：0000~111

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}

void Timer2_Input_XOR_Mode_Init(void)//输入异或
{
    //GPIOA8~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN8, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN8,  GPIO_AF2);
	GPIO_MODE_Init(GPIOA, PIN10, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN10,  GPIO_AF2);
	GPIO_MODE_Init(GPIOA, PIN12, GPIO_MODE_AF);
	GPIO_AF_Init(GPIOA,  PIN12,  GPIO_AF2);

    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER2->PSC = 15999;//预分频
    TIMER2->ARR = 0xffff;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数

	TIMER2->CCR2 = 3;//捕获/比较值2

	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 1<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 0<<0;//IER[0]-更新中断：1-使能，0-关闭

 	TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   1<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   3<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER2->CCMR2 = 0<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   1<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   0<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   1<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上


    TIMER2->CCER = 0<<15//CCER[15]-CC4NP-捕获/比较4互补输出极性：0-高电平有效，1-低电平有效
                |  0<<14//CCER[14]-CC4NE-捕获/比较4互补输出使能：0-关闭，1-开启
                |  0<<13//CCER[13]-CC4P -捕获/比较4输出极性：0-高电平有效，1-低电平有效
                |  0<<12//CCER[12]-CC4E -捕获/比较4输出使能：0-关闭，1-开启
                |  0<<11//CCER[11]-CC3NP-捕获/比较3互补输出极性：0-高电平有效，1-低电平有效
                |  0<<10//CCER[10]-CC3NE-捕获/比较3互补输出使能：0-关闭，1-开启
                |  0<<9 //CCER[9] -CC3P -捕获/比较3输出极性：0-高电平有效，1-低电平有效
                |  0<<8 //CCER[8] -CC3E -捕获/比较3输出使能：0-关闭，1-开启
                |  0<<7 //CCER[7] -CC2NP-捕获/比较2互补输出极性：0-高电平有效，1-低电平有效
                |  0<<6 //CCER[6] -CC2NE-捕获/比较2互补输出使能：0-关闭，1-开启
                |  0<<5 //CCER[5] -CC2P -捕获/比较2输出极性：0-高电平有效，1-低电平有效
                |  0<<4 //CCER[4] -CC2E -捕获/比较2输出使能：0-关闭，1-开启
                |  0<<3 //CCER[3] -CC1NP-捕获/比较1互补输出极性：0-高电平有效，1-低电平有效
                |  0<<2 //CCER[2] -CC1NE-捕获/比较1互补输出使能：0-关闭，1-开启
                |  0<<1 //CCER[1] -CC1P -捕获/比较1输出极性：0-高电平有效，1-低电平有效
                |  0<<0;//CCER[0] -CC1E -捕获/比较1输出使能：0-关闭，1-开启

    TIMER2->CR1 = 5 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 1 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 4 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 0 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER2->ICF = 0 <<12//ICF[15:12]-ICF4-输入捕获4滤波器：0000~111
                | 0 <<8 //ICF[11:8]-ICF3-输入捕获3滤波器：0000~111
                | 0 <<4 //ICF[7:4]-ICF2-输入捕获2滤波器：0000~111
                | 0 <<0;//ICF[3:0]-ICF1-输入捕获1滤波器：0000~111

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}



void Timer2_PWM_Mode_Init(void)//PWM输出
{
	//GPIOA9~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN8, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN9, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN10, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN11, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN12, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN13, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN14, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN15, GPIO_MODE_AF);

	GPIO_AF_Init(GPIOA,  PIN8,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN9,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN10,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN11,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN12,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN13,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN14,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN15,  GPIO_AF2);

    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER2->PSC = 15;//预分频
    TIMER2->ARR = 1000;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数

	TIMER2->CCR1 = 200;//捕获/比较值1
	TIMER2->CCR2 = 400;//捕获/比较值2
	TIMER2->CCR3 = 600;//捕获/比较值3
	TIMER2->CCR4 = 800;//捕获/比较值4

  	TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   7<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER2->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

    TIMER2->CCER = 0<<15//CCER[15]-CC4NP-捕获/比较4互补输出极性：0-高电平有效，1-低电平有效
                |  1<<14//CCER[14]-CC4NE-捕获/比较4互补输出使能：0-关闭，1-开启
                |  0<<13//CCER[13]-CC4P -捕获/比较4输出极性：0-高电平有效，1-低电平有效
                |  1<<12//CCER[12]-CC4E -捕获/比较4输出使能：0-关闭，1-开启
                |  0<<11//CCER[11]-CC3NP-捕获/比较3互补输出极性：0-高电平有效，1-低电平有效
                |  1<<10//CCER[10]-CC3NE-捕获/比较3互补输出使能：0-关闭，1-开启
                |  0<<9 //CCER[9] -CC3P -捕获/比较3输出极性：0-高电平有效，1-低电平有效
                |  1<<8 //CCER[8] -CC3E -捕获/比较3输出使能：0-关闭，1-开启
                |  0<<7 //CCER[7] -CC2NP-捕获/比较2互补输出极性：0-高电平有效，1-低电平有效
                |  1<<6 //CCER[6] -CC2NE-捕获/比较2互补输出使能：0-关闭，1-开启
                |  0<<5 //CCER[5] -CC2P -捕获/比较2输出极性：0-高电平有效，1-低电平有效
                |  1<<4 //CCER[4] -CC2E -捕获/比较2输出使能：0-关闭，1-开启
                |  0<<3 //CCER[3] -CC1NP-捕获/比较1互补输出极性：0-高电平有效，1-低电平有效
                |  1<<2 //CCER[2] -CC1NE-捕获/比较1互补输出使能：0-关闭，1-开启
                |  0<<1 //CCER[1] -CC1P -捕获/比较1输出极性：0-高电平有效，1-低电平有效
                |  1<<0;//CCER[0] -CC1E -捕获/比较1输出使能：0-关闭，1-开启


	TIMER2->IER = 1<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 0<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 0 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 0 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 3 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER2->BDTR = 1 <<15//BDTR[15]-MOE-主输出使能:0-关闭，1-使能
                |  0 <<14//BDTR[14]-AOE-自动输出使能:0-关闭，1-使能
                |  0 <<13//BDTR[13]-BKP-刹车输入极性:0-低电平有效，1-高电平有效
                |  0 <<12//BDTR[12]-BKE-刹车功能使能:0-关闭，1-使能
                |  0 <<11//BDTR[11]-OSSR-运行模式下“关闭状态”选择，定时器不工作时:0-禁止OC/OCN输出，1-一旦CCxE或CCxNE=1,OC/OCN输出空闲电平
                |  0 <<10//BDTR[10]-OSSI-空闲模式下“关闭状态”选择，定时器不工作时:0-禁止OC/OCN输出，1-一旦CCxE或CCxNE=1,OC/OCN输出空闲电平
                |  0 <<8 //BDTR[9:8]-LOCK-锁定设置：00-关闭，01-锁定级别1，10-锁定级别2，11-锁定级别3
                |  0x90<<0;//BDTR[7:0]-LOCK-死区时间设置：

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}


void Timer2_6StepPWM_Mode_Init(void)//6stepPWM输出
{
	//GPIOA9~15复用 timer模式
	GPIO_MODE_Init(GPIOA, PIN8, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN9, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN10, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN11, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN12, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN13, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN14, GPIO_MODE_AF);
	GPIO_MODE_Init(GPIOA, PIN15, GPIO_MODE_AF);

	GPIO_AF_Init(GPIOA,  PIN8,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN9,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN10,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN11,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN12,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN13,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN14,  GPIO_AF2);
	GPIO_AF_Init(GPIOA,  PIN15,  GPIO_AF2);

    TIMER2->CR1 = 0;  //CR1[0]计数器开关：0-关闭，1-开启
    TIMER_CLKEN->CLKEN  |= 1<<8; //CLKEN[8] Timer2时钟开关：1开启，0-关闭
                                 //CLKEN[0] Timer1时钟开关：1开启，0-关闭

    TIMER2->PSC = 15;//预分频
    TIMER2->ARR = 1000;//自动重装寄存器
	TIMER2->RCR = 0;//重复计数

	TIMER2->CCR1 = 500;//捕获/比较值1
	TIMER2->CCR2 = 500;//捕获/比较值2
	TIMER2->CCR3 = 500;//捕获/比较值3
	TIMER2->CCR4 = 500;//捕获/比较值4

 	TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

	TIMER2->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上


    TIMER2->CCER = 0<<15//CCER[15]-CC4NP-捕获/比较4互补输出极性：0-高电平有效，1-低电平有效
                |  1<<14//CCER[14]-CC4NE-捕获/比较4互补输出使能：0-关闭，1-开启
                |  0<<13//CCER[13]-CC4P -捕获/比较4输出极性：0-高电平有效，1-低电平有效
                |  1<<12//CCER[12]-CC4E -捕获/比较4输出使能：0-关闭，1-开启
                |  0<<11//CCER[11]-CC3NP-捕获/比较3互补输出极性：0-高电平有效，1-低电平有效
                |  1<<10//CCER[10]-CC3NE-捕获/比较3互补输出使能：0-关闭，1-开启
                |  0<<9 //CCER[9] -CC3P -捕获/比较3输出极性：0-高电平有效，1-低电平有效
                |  1<<8 //CCER[8] -CC3E -捕获/比较3输出使能：0-关闭，1-开启
                |  0<<7 //CCER[7] -CC2NP-捕获/比较2互补输出极性：0-高电平有效，1-低电平有效
                |  1<<6 //CCER[6] -CC2NE-捕获/比较2互补输出使能：0-关闭，1-开启
                |  0<<5 //CCER[5] -CC2P -捕获/比较2输出极性：0-高电平有效，1-低电平有效
                |  1<<4 //CCER[4] -CC2E -捕获/比较2输出使能：0-关闭，1-开启
                |  0<<3 //CCER[3] -CC1NP-捕获/比较1互补输出极性：0-高电平有效，1-低电平有效
                |  0<<2 //CCER[2] -CC1NE-捕获/比较1互补输出使能：0-关闭，1-开启
                |  0<<1 //CCER[1] -CC1P -捕获/比较1输出极性：0-高电平有效，1-低电平有效
                |  0<<0;//CCER[0] -CC1E -捕获/比较1输出使能：0-关闭，1-开启

	TIMER2->IER = 0<<7 //IER[7]-刹车中断：1-使能，0-关闭
                | 0<<6 //IER[6]-触发中断：1-使能，0-关闭
                | 1<<5 //IER[5]-COM中断：1-使能，0-关闭
                | 0<<4 //IER[4]-捕获/比较4中断：1-使能，0-关闭
                | 0<<3 //IER[3]-捕获/比较3中断：1-使能，0-关闭
                | 0<<2 //IER[2]-捕获/比较2中断：1-使能，0-关闭
                | 0<<1 //IER[1]-捕获/比较1中断：1-使能，0-关闭
                | 1<<0;//IER[0]-更新中断：1-使能，0-关闭

    TIMER2->CR1 = 0 <<28//CR1[30:28]-MMS-触发输出(TRGO)信号选择: 100-OC1EREF, 101-OC2EREF, 110-OC3EREF, 111-OC4EREF
                | 0 <<24//CR1[25:24]-TS-同步计数器触发输入信号选择: 00-TI1的边沿，01-TI1F，10-TI2F，11-ITR
                | 0 <<23//CR1[23]-TI1S-TI1选择：0-TIMx_CH1, 1-TIMx_CH1^TIMx_CH2^TIMx_CH3
                | 0 <<20//CR1[22:20]-SMS-从模式选择：000-关闭从模式，100-复位模式，101-门控模式，110-触发模式，111-外部时钟模式
                | 0 <<19//CR1[19]-CCUS-捕获/比较控制更新选择：0-COM位更新，1-COM位或TRGI上升沿
                | 1 <<18//CR1[18]-CCPC-捕获/比较预装载控制（CCxE,CCxNE,OCxM）：0-不是预装载的，1-在设置COM位后更新
                | 0 <<17//CR1[17]-OIS4N-输出空闲状态：0-死区后OC4N=0,1-死区后OC4N=1
                | 0 <<16//CR1[16]-OIS4-输出空闲状态：0-死区后OC4=0,1-死区后OC4=1
                | 0 <<15//CR1[15]-OIS3N-输出空闲状态：0-死区后OC3N=0,1-死区后OC3N=1
                | 0 <<14//CR1[14]-OIS3-输出空闲状态：0-死区后OC3=0,1-死区后OC3=1
                | 0 <<13//CR1[13]-OIS2N-输出空闲状态：0-死区后OC2N=0,1-死区后OC2N=1
                | 0 <<12//CR1[12]-OIS2-输出空闲状态：0-死区后OC2=0,1-死区后OC2=1
                | 0 <<11//CR1[11]-OIS1N-输出空闲状态：0-死区后OC1N=0,1-死区后OC1N=1
                | 0 <<10//CR1[10]-OIS1-输出空闲状态：0-死区后OC1=0,1-死区后OC1=1
                | 0 <<8//CR1[9:8]-CKD-时钟分频因子：00-tDTS=tCK_INT,01-tDTS=2*tCK_INT,10-tDTS=4*tCK_INT,11-保留
                | 0 <<7//CR1[7]-ARPE-自动重装载预装载使能：0-TIMx_ARR没有缓冲，0-TIMx_ARR装入缓冲
                | 3 <<5//CR1[6:5]-CMS-选择对齐模式：00-边沿对齐，01-中央对齐模式1，10-中央对齐模式2，11-中央对齐模式3
                | 0 <<4//CR1[4]-DIR-计数方向：0-向上计数，1-向下计数
                | 0 <<3//CR1[3]-OPM-单脉冲模式-更新事件时：0-计数器不停止，1-计数器停止
                | 0 <<2//CR1[2]-URS-更新请求源：0-计数器溢出/设置UG位/从模式控制器产生更新，1-计数器溢出
                | 0 <<1//CR1[1]-UDIS-禁止更新：0-允许更新，1-禁止更新
                | 1 <<0;//CR1[0]-CEN-计数器使能：0-禁止计数器，1-使能计数器

    TIMER2->BDTR = 1 <<15//BDTR[15]-MOE-主输出使能:0-关闭，1-使能
                |  0 <<14//BDTR[14]-AOE-自动输出使能:0-关闭，1-使能
                |  0 <<13//BDTR[13]-BKP-刹车输入极性:0-低电平有效，1-高电平有效
                |  0 <<12//BDTR[12]-BKE-刹车功能使能:0-关闭，1-使能
                |  0 <<11//BDTR[11]-OSSR-运行模式下“关闭状态”选择，定时器不工作时:0-禁止OC/OCN输出，1-一旦CCxE或CCxNE=1,OC/OCN输出空闲电平
                |  0 <<10//BDTR[10]-OSSI-空闲模式下“关闭状态”选择，定时器不工作时:0-禁止OC/OCN输出，1-一旦CCxE或CCxNE=1,OC/OCN输出空闲电平
                |  0 <<8 //BDTR[9:8]-LOCK-锁定设置：00-关闭，01-锁定级别1，10-锁定级别2，11-锁定级别3
                |  0x90<<0;//BDTR[7:0]-LOCK-死区时间设置：

	TIMER2->EGR = 0 <<7//EGR[7]-BG-产生刹车事件
                | 0 <<5//EGR[5]-COMG-捕获/比较事件，产生控制更新
                | 0 <<4//EGR[4]-CC4G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<3//EGR[3]-CC3G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<2//EGR[2]-CC2G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 0 <<1//EGR[1]-CC1G-产生捕获/比较事件：1-在CC4上产生一个捕获比较事件
                | 1 <<0;//EGR[0]-UG-产生更新事件：1-重新初始化计数器，并产生一个更新事件
}



void Timer2_Break_IRQhandler(void)
{
    if(TIMER2->SR&0x80)
		TIMER2->SR &= ~0x80;

    //GPIO_Write(GPIOB,PIN11,GPIO_SET);
	//GPIO_Write(GPIOB,PIN11,GPIO_RESET);
}

void Timer2_Update_IRQhandler(void)
{

	if(TIMER2->SR&0x1)
		TIMER2->SR &= ~0x1;
    GPIO_Toggle(GPIOA,PIN8);
    //GPIO_Write(GPIOB,PIN11,GPIO_SET);
	//GPIO_Write(GPIOB,PIN11,GPIO_RESET);
}

uint16_t count1;
uint16_t count2;

void Timer2_Capture_Compare_IRQhandler(void)
{
    //输入捕获模式
    /*
 	if(TIMER2->SR&0x02)//CC1IF
    {
        count1 = TIMER2->CCR1;
        printf(" %d\r\n",count1);
    }
    */

    /*
    //PWM输入
 	if(TIMER2->SR&0x02)//CC1IF
    {
        count1 = TIMER2->CCR1;
        printf(" %d",count1);
    }
 	if(TIMER2->SR&0x04)//CC2IF
    {
        count2 = TIMER2->CCR2;
        printf("\r\n%d",count2);
    }
    */

	if(TIMER2->SR&0xf1e)
		TIMER2->SR &= ~0xf1e;

    //GPIO_Write(GPIOB,PIN11,GPIO_SET);
	//GPIO_Write(GPIOB,PIN11,GPIO_RESET);
}

uint8_t com_set = 0;
void Timer2_Trigger_Commutation_IRQhandler(void)
{
    //6step pwm
    /**/
	if(TIMER2->SR&0x20)
	{
		TIMER2->SR &= ~0x20;
		switch(com_set)
		{
			case 0:
			    //               C0        B-       A+
			    TIMER2->CCER = (0x0<<12)|(0x4<<8)|(0x1<<4)|(0x0); //1+,4-,0close

                TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER2->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   5<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 1:
			    //               C-        B0       A+
				TIMER2->CCER = (0x4<<12)|(0x0<<8)|(0x1<<4)|(0x0); //1+,4-,0close

                TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER2->CCMR2 = 5<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上


				break;

			case 2:
                //               C-        B+       A0
			    TIMER2->CCER = (0x4<<12)|(0x1<<8)|(0x0<<4)|(0x0); //1+,4-,0close
                TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER2->CCMR2 = 5<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 3:
				//               C0        B+       A-
			    TIMER2->CCER = (0x0<<12)|(0x1<<8)|(0x4<<4)|(0x0); //1+,4-,0close

                TIMER2->CCMR1 = 5<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER2->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 4:
				//               C+        B0       A-
			    TIMER2->CCER = (0x1<<12)|(0x0<<8)|(0x4<<4)|(0x0); //1+,4-,0close
                TIMER2->CCMR1 = 5<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER2->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   7<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上

				break;

			case 5:
				//               C+        B-       A0
			    TIMER2->CCER = (0x1<<12)|(0x4<<8)|(0x0<<4)|(0x0); //1+,4-,0close

                TIMER2->CCMR1 = 7<<12//CCMR1[14:12]-OC1M-输出/比较2模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR1[11]-OC1PE-输出/比较2预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR1[9:8]-CC1S-捕获/比较2选择:00-CC1输出，01-IC2映射在TI2上，10-IC2映射在TI1上，11-IC2映射在TRC上
                            |   0<<4 //CCMR1[6:4]-OC1M-输出/比较1模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   0<<3 //CCMR1[3]-OC1PE-输出/比较1预装载使能:0-禁止，1-使能
                            |   1<<0;//CCMR1[1:0]-CC1S-捕获/比较1选择:00-CC1输出，01-IC1映射在TI1上，10-IC1映射在TI2上，11-IC1映射在TRC上

                TIMER2->CCMR2 = 7<<12//CCMR2[14:12]-OC1M-输出/比较4模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<11//CCMR2[11]-OC1PE-输出/比较4预装载使能:0-禁止，1-使能
                            |   0<<8 //CCMR2[9:8]-CC1S-捕获/比较4选择:00-CC1输出，01-IC4映射在TI4上，10-IC4映射在TI3上，11-IC1映射在TRC上
                            |   5<<4 //CCMR2[6:4]-OC1M-输出/比较3模式:000-冻结，001-匹配时设置通道1为有效电平，010-匹配时设置通道1为无效电平，011-翻转，100-强制为无效电平，101-强制为有效电平，110-PWM模式1，111-PWM模式2
                            |   1<<3 //CCMR2[3]-OC1PE-输出/比较3预装载使能:0-禁止，1-使能
                            |   0<<0;//CCMR2[1:0]-CC1S-捕获/比较3选择:00-CC1输出，01-IC3映射在TI3上，10-IC3映射在TI4上，11-IC3映射在TRC上





				break;

			default:
				break;
		}
		com_set++;
		if(com_set==6)
			com_set=0;
	}

    if(TIMER2->SR&0x40)
		TIMER2->SR &= ~0x40;

    //GPIO_Write(GPIOB,PIN11,GPIO_SET);
	//GPIO_Write(GPIOB,PIN11,GPIO_RESET);
}



